// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.15.6
// source: mixmessages.proto

package mixmessages

import (
	context "context"
	messages "gitlab.com/xx_network/comms/messages"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NodeClient is the client API for Node service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeClient interface {
	// Handles AskOnline
	AskOnline(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error)
	// CreatesNewRound makes a new round with a certain ID
	CreateNewRound(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error)
	// UploadUnmixedBatch sends a batch to be processed in the server's realtime
	// Gateway -> Server
	UploadUnmixedBatch(ctx context.Context, opts ...grpc.CallOption) (Node_UploadUnmixedBatchClient, error)
	// FinishRealtime broadcasts when realtime is complete
	FinishRealtime(ctx context.Context, opts ...grpc.CallOption) (Node_FinishRealtimeClient, error)
	// PrecompTestBatch is a server to server streaming broadcast. It simulates
	// sending the completed batch of FinishRealtime, testing for connectivity.
	PrecompTestBatch(ctx context.Context, opts ...grpc.CallOption) (Node_PrecompTestBatchClient, error)
	// PostPhase runs a cMix phase on another node
	PostPhase(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error)
	// StreamPostPhase runs a cMix phase on another node
	// by using unary streaming of slots
	StreamPostPhase(ctx context.Context, opts ...grpc.CallOption) (Node_StreamPostPhaseClient, error)
	// GetRoundBufferInfo returns the # of rounds ready for messages
	GetRoundBufferInfo(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*RoundBufferInfo, error)
	// RequestClientKey generates a nonce for user registration
	RequestClientKey(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*SignedKeyResponse, error)
	// PostPrecompResult finalizes the precomputation results with each node from the last node
	// sending the final PayloadA and PayloadB precomputations
	PostPrecompResult(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error)
	//
	GetMeasure(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*RoundMetrics, error)
	// Gateway -> Server unified polling
	Poll(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*ServerPollResponse, error)
	// Streams a completed batch
	// Server -> Gateway
	DownloadMixedBatch(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (Node_DownloadMixedBatchClient, error)
	// Round trip ping comm
	SendRoundTripPing(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error)
	// Round error comm
	RoundError(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error)
	// Server -> Gateway permissioning address
	GetPermissioningAddress(ctx context.Context, in *messages.Ping, opts ...grpc.CallOption) (*StrAddress, error)
	// Server -> Server initiating multi-party round DH key generation
	StartSharePhase(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error)
	// Server -> Server passing state of multi-party round DH key generation
	SharePhaseRound(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error)
	// Server -> Server received final key
	ShareFinalKey(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error)
}

type nodeClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeClient(cc grpc.ClientConnInterface) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) AskOnline(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/AskOnline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) CreateNewRound(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/CreateNewRound", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) UploadUnmixedBatch(ctx context.Context, opts ...grpc.CallOption) (Node_UploadUnmixedBatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &Node_ServiceDesc.Streams[0], "/mixmessages.Node/UploadUnmixedBatch", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeUploadUnmixedBatchClient{stream}
	return x, nil
}

type Node_UploadUnmixedBatchClient interface {
	Send(*Slot) error
	CloseAndRecv() (*messages.Ack, error)
	grpc.ClientStream
}

type nodeUploadUnmixedBatchClient struct {
	grpc.ClientStream
}

func (x *nodeUploadUnmixedBatchClient) Send(m *Slot) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodeUploadUnmixedBatchClient) CloseAndRecv() (*messages.Ack, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(messages.Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeClient) FinishRealtime(ctx context.Context, opts ...grpc.CallOption) (Node_FinishRealtimeClient, error) {
	stream, err := c.cc.NewStream(ctx, &Node_ServiceDesc.Streams[1], "/mixmessages.Node/FinishRealtime", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeFinishRealtimeClient{stream}
	return x, nil
}

type Node_FinishRealtimeClient interface {
	Send(*Slot) error
	CloseAndRecv() (*messages.Ack, error)
	grpc.ClientStream
}

type nodeFinishRealtimeClient struct {
	grpc.ClientStream
}

func (x *nodeFinishRealtimeClient) Send(m *Slot) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodeFinishRealtimeClient) CloseAndRecv() (*messages.Ack, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(messages.Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeClient) PrecompTestBatch(ctx context.Context, opts ...grpc.CallOption) (Node_PrecompTestBatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &Node_ServiceDesc.Streams[2], "/mixmessages.Node/PrecompTestBatch", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodePrecompTestBatchClient{stream}
	return x, nil
}

type Node_PrecompTestBatchClient interface {
	Send(*Slot) error
	CloseAndRecv() (*messages.Ack, error)
	grpc.ClientStream
}

type nodePrecompTestBatchClient struct {
	grpc.ClientStream
}

func (x *nodePrecompTestBatchClient) Send(m *Slot) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodePrecompTestBatchClient) CloseAndRecv() (*messages.Ack, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(messages.Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeClient) PostPhase(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/PostPhase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) StreamPostPhase(ctx context.Context, opts ...grpc.CallOption) (Node_StreamPostPhaseClient, error) {
	stream, err := c.cc.NewStream(ctx, &Node_ServiceDesc.Streams[3], "/mixmessages.Node/StreamPostPhase", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeStreamPostPhaseClient{stream}
	return x, nil
}

type Node_StreamPostPhaseClient interface {
	Send(*Slot) error
	CloseAndRecv() (*messages.Ack, error)
	grpc.ClientStream
}

type nodeStreamPostPhaseClient struct {
	grpc.ClientStream
}

func (x *nodeStreamPostPhaseClient) Send(m *Slot) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodeStreamPostPhaseClient) CloseAndRecv() (*messages.Ack, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(messages.Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeClient) GetRoundBufferInfo(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*RoundBufferInfo, error) {
	out := new(RoundBufferInfo)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/GetRoundBufferInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) RequestClientKey(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*SignedKeyResponse, error) {
	out := new(SignedKeyResponse)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/RequestClientKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) PostPrecompResult(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/PostPrecompResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetMeasure(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*RoundMetrics, error) {
	out := new(RoundMetrics)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/GetMeasure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Poll(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*ServerPollResponse, error) {
	out := new(ServerPollResponse)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/Poll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) DownloadMixedBatch(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (Node_DownloadMixedBatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &Node_ServiceDesc.Streams[4], "/mixmessages.Node/DownloadMixedBatch", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeDownloadMixedBatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Node_DownloadMixedBatchClient interface {
	Recv() (*Slot, error)
	grpc.ClientStream
}

type nodeDownloadMixedBatchClient struct {
	grpc.ClientStream
}

func (x *nodeDownloadMixedBatchClient) Recv() (*Slot, error) {
	m := new(Slot)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeClient) SendRoundTripPing(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/SendRoundTripPing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) RoundError(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/RoundError", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetPermissioningAddress(ctx context.Context, in *messages.Ping, opts ...grpc.CallOption) (*StrAddress, error) {
	out := new(StrAddress)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/GetPermissioningAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) StartSharePhase(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/StartSharePhase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) SharePhaseRound(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/SharePhaseRound", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ShareFinalKey(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/ShareFinalKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServer is the server API for Node service.
// All implementations must embed UnimplementedNodeServer
// for forward compatibility
type NodeServer interface {
	// Handles AskOnline
	AskOnline(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error)
	// CreatesNewRound makes a new round with a certain ID
	CreateNewRound(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error)
	// UploadUnmixedBatch sends a batch to be processed in the server's realtime
	// Gateway -> Server
	UploadUnmixedBatch(Node_UploadUnmixedBatchServer) error
	// FinishRealtime broadcasts when realtime is complete
	FinishRealtime(Node_FinishRealtimeServer) error
	// PrecompTestBatch is a server to server streaming broadcast. It simulates
	// sending the completed batch of FinishRealtime, testing for connectivity.
	PrecompTestBatch(Node_PrecompTestBatchServer) error
	// PostPhase runs a cMix phase on another node
	PostPhase(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error)
	// StreamPostPhase runs a cMix phase on another node
	// by using unary streaming of slots
	StreamPostPhase(Node_StreamPostPhaseServer) error
	// GetRoundBufferInfo returns the # of rounds ready for messages
	GetRoundBufferInfo(context.Context, *messages.AuthenticatedMessage) (*RoundBufferInfo, error)
	// RequestClientKey generates a nonce for user registration
	RequestClientKey(context.Context, *messages.AuthenticatedMessage) (*SignedKeyResponse, error)
	// PostPrecompResult finalizes the precomputation results with each node from the last node
	// sending the final PayloadA and PayloadB precomputations
	PostPrecompResult(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error)
	//
	GetMeasure(context.Context, *messages.AuthenticatedMessage) (*RoundMetrics, error)
	// Gateway -> Server unified polling
	Poll(context.Context, *messages.AuthenticatedMessage) (*ServerPollResponse, error)
	// Streams a completed batch
	// Server -> Gateway
	DownloadMixedBatch(*messages.AuthenticatedMessage, Node_DownloadMixedBatchServer) error
	// Round trip ping comm
	SendRoundTripPing(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error)
	// Round error comm
	RoundError(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error)
	// Server -> Gateway permissioning address
	GetPermissioningAddress(context.Context, *messages.Ping) (*StrAddress, error)
	// Server -> Server initiating multi-party round DH key generation
	StartSharePhase(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error)
	// Server -> Server passing state of multi-party round DH key generation
	SharePhaseRound(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error)
	// Server -> Server received final key
	ShareFinalKey(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error)
	mustEmbedUnimplementedNodeServer()
}

// UnimplementedNodeServer must be embedded to have forward compatible implementations.
type UnimplementedNodeServer struct {
}

func (UnimplementedNodeServer) AskOnline(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AskOnline not implemented")
}
func (UnimplementedNodeServer) CreateNewRound(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewRound not implemented")
}
func (UnimplementedNodeServer) UploadUnmixedBatch(Node_UploadUnmixedBatchServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadUnmixedBatch not implemented")
}
func (UnimplementedNodeServer) FinishRealtime(Node_FinishRealtimeServer) error {
	return status.Errorf(codes.Unimplemented, "method FinishRealtime not implemented")
}
func (UnimplementedNodeServer) PrecompTestBatch(Node_PrecompTestBatchServer) error {
	return status.Errorf(codes.Unimplemented, "method PrecompTestBatch not implemented")
}
func (UnimplementedNodeServer) PostPhase(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostPhase not implemented")
}
func (UnimplementedNodeServer) StreamPostPhase(Node_StreamPostPhaseServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamPostPhase not implemented")
}
func (UnimplementedNodeServer) GetRoundBufferInfo(context.Context, *messages.AuthenticatedMessage) (*RoundBufferInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoundBufferInfo not implemented")
}
func (UnimplementedNodeServer) RequestClientKey(context.Context, *messages.AuthenticatedMessage) (*SignedKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestClientKey not implemented")
}
func (UnimplementedNodeServer) PostPrecompResult(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostPrecompResult not implemented")
}
func (UnimplementedNodeServer) GetMeasure(context.Context, *messages.AuthenticatedMessage) (*RoundMetrics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMeasure not implemented")
}
func (UnimplementedNodeServer) Poll(context.Context, *messages.AuthenticatedMessage) (*ServerPollResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Poll not implemented")
}
func (UnimplementedNodeServer) DownloadMixedBatch(*messages.AuthenticatedMessage, Node_DownloadMixedBatchServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadMixedBatch not implemented")
}
func (UnimplementedNodeServer) SendRoundTripPing(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendRoundTripPing not implemented")
}
func (UnimplementedNodeServer) RoundError(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoundError not implemented")
}
func (UnimplementedNodeServer) GetPermissioningAddress(context.Context, *messages.Ping) (*StrAddress, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPermissioningAddress not implemented")
}
func (UnimplementedNodeServer) StartSharePhase(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartSharePhase not implemented")
}
func (UnimplementedNodeServer) SharePhaseRound(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SharePhaseRound not implemented")
}
func (UnimplementedNodeServer) ShareFinalKey(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShareFinalKey not implemented")
}
func (UnimplementedNodeServer) mustEmbedUnimplementedNodeServer() {}

// UnsafeNodeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeServer will
// result in compilation errors.
type UnsafeNodeServer interface {
	mustEmbedUnimplementedNodeServer()
}

func RegisterNodeServer(s grpc.ServiceRegistrar, srv NodeServer) {
	s.RegisterService(&Node_ServiceDesc, srv)
}

func _Node_AskOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).AskOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/AskOnline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).AskOnline(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_CreateNewRound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).CreateNewRound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/CreateNewRound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).CreateNewRound(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_UploadUnmixedBatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeServer).UploadUnmixedBatch(&nodeUploadUnmixedBatchServer{stream})
}

type Node_UploadUnmixedBatchServer interface {
	SendAndClose(*messages.Ack) error
	Recv() (*Slot, error)
	grpc.ServerStream
}

type nodeUploadUnmixedBatchServer struct {
	grpc.ServerStream
}

func (x *nodeUploadUnmixedBatchServer) SendAndClose(m *messages.Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodeUploadUnmixedBatchServer) Recv() (*Slot, error) {
	m := new(Slot)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Node_FinishRealtime_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeServer).FinishRealtime(&nodeFinishRealtimeServer{stream})
}

type Node_FinishRealtimeServer interface {
	SendAndClose(*messages.Ack) error
	Recv() (*Slot, error)
	grpc.ServerStream
}

type nodeFinishRealtimeServer struct {
	grpc.ServerStream
}

func (x *nodeFinishRealtimeServer) SendAndClose(m *messages.Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodeFinishRealtimeServer) Recv() (*Slot, error) {
	m := new(Slot)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Node_PrecompTestBatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeServer).PrecompTestBatch(&nodePrecompTestBatchServer{stream})
}

type Node_PrecompTestBatchServer interface {
	SendAndClose(*messages.Ack) error
	Recv() (*Slot, error)
	grpc.ServerStream
}

type nodePrecompTestBatchServer struct {
	grpc.ServerStream
}

func (x *nodePrecompTestBatchServer) SendAndClose(m *messages.Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodePrecompTestBatchServer) Recv() (*Slot, error) {
	m := new(Slot)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Node_PostPhase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).PostPhase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/PostPhase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).PostPhase(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_StreamPostPhase_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeServer).StreamPostPhase(&nodeStreamPostPhaseServer{stream})
}

type Node_StreamPostPhaseServer interface {
	SendAndClose(*messages.Ack) error
	Recv() (*Slot, error)
	grpc.ServerStream
}

type nodeStreamPostPhaseServer struct {
	grpc.ServerStream
}

func (x *nodeStreamPostPhaseServer) SendAndClose(m *messages.Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodeStreamPostPhaseServer) Recv() (*Slot, error) {
	m := new(Slot)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Node_GetRoundBufferInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetRoundBufferInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/GetRoundBufferInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetRoundBufferInfo(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_RequestClientKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).RequestClientKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/RequestClientKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).RequestClientKey(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_PostPrecompResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).PostPrecompResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/PostPrecompResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).PostPrecompResult(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetMeasure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetMeasure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/GetMeasure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetMeasure(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_Poll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Poll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/Poll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Poll(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_DownloadMixedBatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(messages.AuthenticatedMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeServer).DownloadMixedBatch(m, &nodeDownloadMixedBatchServer{stream})
}

type Node_DownloadMixedBatchServer interface {
	Send(*Slot) error
	grpc.ServerStream
}

type nodeDownloadMixedBatchServer struct {
	grpc.ServerStream
}

func (x *nodeDownloadMixedBatchServer) Send(m *Slot) error {
	return x.ServerStream.SendMsg(m)
}

func _Node_SendRoundTripPing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).SendRoundTripPing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/SendRoundTripPing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).SendRoundTripPing(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_RoundError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).RoundError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/RoundError",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).RoundError(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetPermissioningAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.Ping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetPermissioningAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/GetPermissioningAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetPermissioningAddress(ctx, req.(*messages.Ping))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_StartSharePhase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).StartSharePhase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/StartSharePhase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).StartSharePhase(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_SharePhaseRound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).SharePhaseRound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/SharePhaseRound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).SharePhaseRound(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ShareFinalKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ShareFinalKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/ShareFinalKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ShareFinalKey(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

// Node_ServiceDesc is the grpc.ServiceDesc for Node service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Node_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.Node",
	HandlerType: (*NodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AskOnline",
			Handler:    _Node_AskOnline_Handler,
		},
		{
			MethodName: "CreateNewRound",
			Handler:    _Node_CreateNewRound_Handler,
		},
		{
			MethodName: "PostPhase",
			Handler:    _Node_PostPhase_Handler,
		},
		{
			MethodName: "GetRoundBufferInfo",
			Handler:    _Node_GetRoundBufferInfo_Handler,
		},
		{
			MethodName: "RequestClientKey",
			Handler:    _Node_RequestClientKey_Handler,
		},
		{
			MethodName: "PostPrecompResult",
			Handler:    _Node_PostPrecompResult_Handler,
		},
		{
			MethodName: "GetMeasure",
			Handler:    _Node_GetMeasure_Handler,
		},
		{
			MethodName: "Poll",
			Handler:    _Node_Poll_Handler,
		},
		{
			MethodName: "SendRoundTripPing",
			Handler:    _Node_SendRoundTripPing_Handler,
		},
		{
			MethodName: "RoundError",
			Handler:    _Node_RoundError_Handler,
		},
		{
			MethodName: "GetPermissioningAddress",
			Handler:    _Node_GetPermissioningAddress_Handler,
		},
		{
			MethodName: "StartSharePhase",
			Handler:    _Node_StartSharePhase_Handler,
		},
		{
			MethodName: "SharePhaseRound",
			Handler:    _Node_SharePhaseRound_Handler,
		},
		{
			MethodName: "ShareFinalKey",
			Handler:    _Node_ShareFinalKey_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadUnmixedBatch",
			Handler:       _Node_UploadUnmixedBatch_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "FinishRealtime",
			Handler:       _Node_FinishRealtime_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "PrecompTestBatch",
			Handler:       _Node_PrecompTestBatch_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamPostPhase",
			Handler:       _Node_StreamPostPhase_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadMixedBatch",
			Handler:       _Node_DownloadMixedBatch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mixmessages.proto",
}

// GatewayClient is the client API for Gateway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GatewayClient interface {
	// RequestClientKey returns a Nonce to the user
	RequestClientKey(ctx context.Context, in *SignedClientKeyRequest, opts ...grpc.CallOption) (*SignedKeyResponse, error)
	// PutMessage on the cMix Gateway (client -> gateway)
	PutMessage(ctx context.Context, in *GatewaySlot, opts ...grpc.CallOption) (*GatewaySlotResponse, error)
	// PutMessage on the cMix Gateway (client -> gateway)
	PutManyMessages(ctx context.Context, in *GatewaySlots, opts ...grpc.CallOption) (*GatewaySlotResponse, error)
	// PutMessage on the cMix Gateway (gateway -> gateway)
	PutMessageProxy(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*GatewaySlotResponse, error)
	// PutMessage on the cMix Gateway (gateway -> gateway)
	PutManyMessagesProxy(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*GatewaySlotResponse, error)
	// Client -> Gateway unified polling
	Poll(ctx context.Context, in *GatewayPoll, opts ...grpc.CallOption) (Gateway_PollClient, error)
	// Client -> Gateway historical round request
	RequestHistoricalRounds(ctx context.Context, in *HistoricalRounds, opts ...grpc.CallOption) (*HistoricalRoundsResponse, error)
	// Client -> Gateway message request
	RequestMessages(ctx context.Context, in *GetMessages, opts ...grpc.CallOption) (*GetMessagesResponse, error)
}

type gatewayClient struct {
	cc grpc.ClientConnInterface
}

func NewGatewayClient(cc grpc.ClientConnInterface) GatewayClient {
	return &gatewayClient{cc}
}

func (c *gatewayClient) RequestClientKey(ctx context.Context, in *SignedClientKeyRequest, opts ...grpc.CallOption) (*SignedKeyResponse, error) {
	out := new(SignedKeyResponse)
	err := c.cc.Invoke(ctx, "/mixmessages.Gateway/RequestClientKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) PutMessage(ctx context.Context, in *GatewaySlot, opts ...grpc.CallOption) (*GatewaySlotResponse, error) {
	out := new(GatewaySlotResponse)
	err := c.cc.Invoke(ctx, "/mixmessages.Gateway/PutMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) PutManyMessages(ctx context.Context, in *GatewaySlots, opts ...grpc.CallOption) (*GatewaySlotResponse, error) {
	out := new(GatewaySlotResponse)
	err := c.cc.Invoke(ctx, "/mixmessages.Gateway/PutManyMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) PutMessageProxy(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*GatewaySlotResponse, error) {
	out := new(GatewaySlotResponse)
	err := c.cc.Invoke(ctx, "/mixmessages.Gateway/PutMessageProxy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) PutManyMessagesProxy(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*GatewaySlotResponse, error) {
	out := new(GatewaySlotResponse)
	err := c.cc.Invoke(ctx, "/mixmessages.Gateway/PutManyMessagesProxy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Poll(ctx context.Context, in *GatewayPoll, opts ...grpc.CallOption) (Gateway_PollClient, error) {
	stream, err := c.cc.NewStream(ctx, &Gateway_ServiceDesc.Streams[0], "/mixmessages.Gateway/Poll", opts...)
	if err != nil {
		return nil, err
	}
	x := &gatewayPollClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Gateway_PollClient interface {
	Recv() (*StreamChunk, error)
	grpc.ClientStream
}

type gatewayPollClient struct {
	grpc.ClientStream
}

func (x *gatewayPollClient) Recv() (*StreamChunk, error) {
	m := new(StreamChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gatewayClient) RequestHistoricalRounds(ctx context.Context, in *HistoricalRounds, opts ...grpc.CallOption) (*HistoricalRoundsResponse, error) {
	out := new(HistoricalRoundsResponse)
	err := c.cc.Invoke(ctx, "/mixmessages.Gateway/RequestHistoricalRounds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) RequestMessages(ctx context.Context, in *GetMessages, opts ...grpc.CallOption) (*GetMessagesResponse, error) {
	out := new(GetMessagesResponse)
	err := c.cc.Invoke(ctx, "/mixmessages.Gateway/RequestMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayServer is the server API for Gateway service.
// All implementations must embed UnimplementedGatewayServer
// for forward compatibility
type GatewayServer interface {
	// RequestClientKey returns a Nonce to the user
	RequestClientKey(context.Context, *SignedClientKeyRequest) (*SignedKeyResponse, error)
	// PutMessage on the cMix Gateway (client -> gateway)
	PutMessage(context.Context, *GatewaySlot) (*GatewaySlotResponse, error)
	// PutMessage on the cMix Gateway (client -> gateway)
	PutManyMessages(context.Context, *GatewaySlots) (*GatewaySlotResponse, error)
	// PutMessage on the cMix Gateway (gateway -> gateway)
	PutMessageProxy(context.Context, *messages.AuthenticatedMessage) (*GatewaySlotResponse, error)
	// PutMessage on the cMix Gateway (gateway -> gateway)
	PutManyMessagesProxy(context.Context, *messages.AuthenticatedMessage) (*GatewaySlotResponse, error)
	// Client -> Gateway unified polling
	Poll(*GatewayPoll, Gateway_PollServer) error
	// Client -> Gateway historical round request
	RequestHistoricalRounds(context.Context, *HistoricalRounds) (*HistoricalRoundsResponse, error)
	// Client -> Gateway message request
	RequestMessages(context.Context, *GetMessages) (*GetMessagesResponse, error)
	mustEmbedUnimplementedGatewayServer()
}

// UnimplementedGatewayServer must be embedded to have forward compatible implementations.
type UnimplementedGatewayServer struct {
}

func (UnimplementedGatewayServer) RequestClientKey(context.Context, *SignedClientKeyRequest) (*SignedKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestClientKey not implemented")
}
func (UnimplementedGatewayServer) PutMessage(context.Context, *GatewaySlot) (*GatewaySlotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutMessage not implemented")
}
func (UnimplementedGatewayServer) PutManyMessages(context.Context, *GatewaySlots) (*GatewaySlotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutManyMessages not implemented")
}
func (UnimplementedGatewayServer) PutMessageProxy(context.Context, *messages.AuthenticatedMessage) (*GatewaySlotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutMessageProxy not implemented")
}
func (UnimplementedGatewayServer) PutManyMessagesProxy(context.Context, *messages.AuthenticatedMessage) (*GatewaySlotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutManyMessagesProxy not implemented")
}
func (UnimplementedGatewayServer) Poll(*GatewayPoll, Gateway_PollServer) error {
	return status.Errorf(codes.Unimplemented, "method Poll not implemented")
}
func (UnimplementedGatewayServer) RequestHistoricalRounds(context.Context, *HistoricalRounds) (*HistoricalRoundsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestHistoricalRounds not implemented")
}
func (UnimplementedGatewayServer) RequestMessages(context.Context, *GetMessages) (*GetMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestMessages not implemented")
}
func (UnimplementedGatewayServer) mustEmbedUnimplementedGatewayServer() {}

// UnsafeGatewayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GatewayServer will
// result in compilation errors.
type UnsafeGatewayServer interface {
	mustEmbedUnimplementedGatewayServer()
}

func RegisterGatewayServer(s grpc.ServiceRegistrar, srv GatewayServer) {
	s.RegisterService(&Gateway_ServiceDesc, srv)
}

func _Gateway_RequestClientKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignedClientKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).RequestClientKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/RequestClientKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).RequestClientKey(ctx, req.(*SignedClientKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_PutMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatewaySlot)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).PutMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/PutMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).PutMessage(ctx, req.(*GatewaySlot))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_PutManyMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatewaySlots)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).PutManyMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/PutManyMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).PutManyMessages(ctx, req.(*GatewaySlots))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_PutMessageProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).PutMessageProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/PutMessageProxy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).PutMessageProxy(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_PutManyMessagesProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).PutManyMessagesProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/PutManyMessagesProxy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).PutManyMessagesProxy(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Poll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GatewayPoll)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GatewayServer).Poll(m, &gatewayPollServer{stream})
}

type Gateway_PollServer interface {
	Send(*StreamChunk) error
	grpc.ServerStream
}

type gatewayPollServer struct {
	grpc.ServerStream
}

func (x *gatewayPollServer) Send(m *StreamChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _Gateway_RequestHistoricalRounds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HistoricalRounds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).RequestHistoricalRounds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/RequestHistoricalRounds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).RequestHistoricalRounds(ctx, req.(*HistoricalRounds))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_RequestMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMessages)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).RequestMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/RequestMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).RequestMessages(ctx, req.(*GetMessages))
	}
	return interceptor(ctx, in, info, handler)
}

// Gateway_ServiceDesc is the grpc.ServiceDesc for Gateway service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Gateway_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.Gateway",
	HandlerType: (*GatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestClientKey",
			Handler:    _Gateway_RequestClientKey_Handler,
		},
		{
			MethodName: "PutMessage",
			Handler:    _Gateway_PutMessage_Handler,
		},
		{
			MethodName: "PutManyMessages",
			Handler:    _Gateway_PutManyMessages_Handler,
		},
		{
			MethodName: "PutMessageProxy",
			Handler:    _Gateway_PutMessageProxy_Handler,
		},
		{
			MethodName: "PutManyMessagesProxy",
			Handler:    _Gateway_PutManyMessagesProxy_Handler,
		},
		{
			MethodName: "RequestHistoricalRounds",
			Handler:    _Gateway_RequestHistoricalRounds_Handler,
		},
		{
			MethodName: "RequestMessages",
			Handler:    _Gateway_RequestMessages_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Poll",
			Handler:       _Gateway_Poll_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mixmessages.proto",
}

// ClientRegistrarClient is the client API for ClientRegistrar service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClientRegistrarClient interface {
	// Client uses this to register its user with the system
	RegisterUser(ctx context.Context, in *ClientRegistration, opts ...grpc.CallOption) (*SignedClientRegistrationConfirmations, error)
}

type clientRegistrarClient struct {
	cc grpc.ClientConnInterface
}

func NewClientRegistrarClient(cc grpc.ClientConnInterface) ClientRegistrarClient {
	return &clientRegistrarClient{cc}
}

func (c *clientRegistrarClient) RegisterUser(ctx context.Context, in *ClientRegistration, opts ...grpc.CallOption) (*SignedClientRegistrationConfirmations, error) {
	out := new(SignedClientRegistrationConfirmations)
	err := c.cc.Invoke(ctx, "/mixmessages.ClientRegistrar/RegisterUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClientRegistrarServer is the server API for ClientRegistrar service.
// All implementations must embed UnimplementedClientRegistrarServer
// for forward compatibility
type ClientRegistrarServer interface {
	// Client uses this to register its user with the system
	RegisterUser(context.Context, *ClientRegistration) (*SignedClientRegistrationConfirmations, error)
	mustEmbedUnimplementedClientRegistrarServer()
}

// UnimplementedClientRegistrarServer must be embedded to have forward compatible implementations.
type UnimplementedClientRegistrarServer struct {
}

func (UnimplementedClientRegistrarServer) RegisterUser(context.Context, *ClientRegistration) (*SignedClientRegistrationConfirmations, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterUser not implemented")
}
func (UnimplementedClientRegistrarServer) mustEmbedUnimplementedClientRegistrarServer() {}

// UnsafeClientRegistrarServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClientRegistrarServer will
// result in compilation errors.
type UnsafeClientRegistrarServer interface {
	mustEmbedUnimplementedClientRegistrarServer()
}

func RegisterClientRegistrarServer(s grpc.ServiceRegistrar, srv ClientRegistrarServer) {
	s.RegisterService(&ClientRegistrar_ServiceDesc, srv)
}

func _ClientRegistrar_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientRegistrarServer).RegisterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.ClientRegistrar/RegisterUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientRegistrarServer).RegisterUser(ctx, req.(*ClientRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

// ClientRegistrar_ServiceDesc is the grpc.ServiceDesc for ClientRegistrar service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClientRegistrar_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.ClientRegistrar",
	HandlerType: (*ClientRegistrarServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterUser",
			Handler:    _ClientRegistrar_RegisterUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}

// RegistrationClient is the client API for Registration service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegistrationClient interface {
	// Node registration for the permissioning server
	RegisterNode(ctx context.Context, in *NodeRegistration, opts ...grpc.CallOption) (*messages.Ack, error)
	// Obtain NDF from the Registration Server
	PollNdf(ctx context.Context, in *NDFHash, opts ...grpc.CallOption) (*NDF, error)
	// Server -> Permissioning unified polling
	Poll(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*PermissionPollResponse, error)
	// Checks if node has been registered
	CheckRegistration(ctx context.Context, in *RegisteredNodeCheck, opts ...grpc.CallOption) (*RegisteredNodeConfirmation, error)
}

type registrationClient struct {
	cc grpc.ClientConnInterface
}

func NewRegistrationClient(cc grpc.ClientConnInterface) RegistrationClient {
	return &registrationClient{cc}
}

func (c *registrationClient) RegisterNode(ctx context.Context, in *NodeRegistration, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Registration/RegisterNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registrationClient) PollNdf(ctx context.Context, in *NDFHash, opts ...grpc.CallOption) (*NDF, error) {
	out := new(NDF)
	err := c.cc.Invoke(ctx, "/mixmessages.Registration/PollNdf", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registrationClient) Poll(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*PermissionPollResponse, error) {
	out := new(PermissionPollResponse)
	err := c.cc.Invoke(ctx, "/mixmessages.Registration/Poll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registrationClient) CheckRegistration(ctx context.Context, in *RegisteredNodeCheck, opts ...grpc.CallOption) (*RegisteredNodeConfirmation, error) {
	out := new(RegisteredNodeConfirmation)
	err := c.cc.Invoke(ctx, "/mixmessages.Registration/CheckRegistration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegistrationServer is the server API for Registration service.
// All implementations must embed UnimplementedRegistrationServer
// for forward compatibility
type RegistrationServer interface {
	// Node registration for the permissioning server
	RegisterNode(context.Context, *NodeRegistration) (*messages.Ack, error)
	// Obtain NDF from the Registration Server
	PollNdf(context.Context, *NDFHash) (*NDF, error)
	// Server -> Permissioning unified polling
	Poll(context.Context, *messages.AuthenticatedMessage) (*PermissionPollResponse, error)
	// Checks if node has been registered
	CheckRegistration(context.Context, *RegisteredNodeCheck) (*RegisteredNodeConfirmation, error)
	mustEmbedUnimplementedRegistrationServer()
}

// UnimplementedRegistrationServer must be embedded to have forward compatible implementations.
type UnimplementedRegistrationServer struct {
}

func (UnimplementedRegistrationServer) RegisterNode(context.Context, *NodeRegistration) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterNode not implemented")
}
func (UnimplementedRegistrationServer) PollNdf(context.Context, *NDFHash) (*NDF, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollNdf not implemented")
}
func (UnimplementedRegistrationServer) Poll(context.Context, *messages.AuthenticatedMessage) (*PermissionPollResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Poll not implemented")
}
func (UnimplementedRegistrationServer) CheckRegistration(context.Context, *RegisteredNodeCheck) (*RegisteredNodeConfirmation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckRegistration not implemented")
}
func (UnimplementedRegistrationServer) mustEmbedUnimplementedRegistrationServer() {}

// UnsafeRegistrationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegistrationServer will
// result in compilation errors.
type UnsafeRegistrationServer interface {
	mustEmbedUnimplementedRegistrationServer()
}

func RegisterRegistrationServer(s grpc.ServiceRegistrar, srv RegistrationServer) {
	s.RegisterService(&Registration_ServiceDesc, srv)
}

func _Registration_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistrationServer).RegisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Registration/RegisterNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistrationServer).RegisterNode(ctx, req.(*NodeRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registration_PollNdf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NDFHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistrationServer).PollNdf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Registration/PollNdf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistrationServer).PollNdf(ctx, req.(*NDFHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registration_Poll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistrationServer).Poll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Registration/Poll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistrationServer).Poll(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registration_CheckRegistration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisteredNodeCheck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistrationServer).CheckRegistration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Registration/CheckRegistration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistrationServer).CheckRegistration(ctx, req.(*RegisteredNodeCheck))
	}
	return interceptor(ctx, in, info, handler)
}

// Registration_ServiceDesc is the grpc.ServiceDesc for Registration service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Registration_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.Registration",
	HandlerType: (*RegistrationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterNode",
			Handler:    _Registration_RegisterNode_Handler,
		},
		{
			MethodName: "PollNdf",
			Handler:    _Registration_PollNdf_Handler,
		},
		{
			MethodName: "Poll",
			Handler:    _Registration_Poll_Handler,
		},
		{
			MethodName: "CheckRegistration",
			Handler:    _Registration_CheckRegistration_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}

// NotificationBotClient is the client API for NotificationBot service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotificationBotClient interface {
	// Unregister clients from push notifications
	UnregisterForNotifications(ctx context.Context, in *NotificationUnregisterRequest, opts ...grpc.CallOption) (*messages.Ack, error)
	// Register clients from push notifications
	RegisterForNotifications(ctx context.Context, in *NotificationRegisterRequest, opts ...grpc.CallOption) (*messages.Ack, error)
	// Gateway -> Notifications notification data
	ReceiveNotificationBatch(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error)
}

type notificationBotClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationBotClient(cc grpc.ClientConnInterface) NotificationBotClient {
	return &notificationBotClient{cc}
}

func (c *notificationBotClient) UnregisterForNotifications(ctx context.Context, in *NotificationUnregisterRequest, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.NotificationBot/UnregisterForNotifications", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationBotClient) RegisterForNotifications(ctx context.Context, in *NotificationRegisterRequest, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.NotificationBot/RegisterForNotifications", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationBotClient) ReceiveNotificationBatch(ctx context.Context, in *messages.AuthenticatedMessage, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.NotificationBot/ReceiveNotificationBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationBotServer is the server API for NotificationBot service.
// All implementations must embed UnimplementedNotificationBotServer
// for forward compatibility
type NotificationBotServer interface {
	// Unregister clients from push notifications
	UnregisterForNotifications(context.Context, *NotificationUnregisterRequest) (*messages.Ack, error)
	// Register clients from push notifications
	RegisterForNotifications(context.Context, *NotificationRegisterRequest) (*messages.Ack, error)
	// Gateway -> Notifications notification data
	ReceiveNotificationBatch(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error)
	mustEmbedUnimplementedNotificationBotServer()
}

// UnimplementedNotificationBotServer must be embedded to have forward compatible implementations.
type UnimplementedNotificationBotServer struct {
}

func (UnimplementedNotificationBotServer) UnregisterForNotifications(context.Context, *NotificationUnregisterRequest) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterForNotifications not implemented")
}
func (UnimplementedNotificationBotServer) RegisterForNotifications(context.Context, *NotificationRegisterRequest) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterForNotifications not implemented")
}
func (UnimplementedNotificationBotServer) ReceiveNotificationBatch(context.Context, *messages.AuthenticatedMessage) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveNotificationBatch not implemented")
}
func (UnimplementedNotificationBotServer) mustEmbedUnimplementedNotificationBotServer() {}

// UnsafeNotificationBotServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationBotServer will
// result in compilation errors.
type UnsafeNotificationBotServer interface {
	mustEmbedUnimplementedNotificationBotServer()
}

func RegisterNotificationBotServer(s grpc.ServiceRegistrar, srv NotificationBotServer) {
	s.RegisterService(&NotificationBot_ServiceDesc, srv)
}

func _NotificationBot_UnregisterForNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationUnregisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationBotServer).UnregisterForNotifications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.NotificationBot/UnregisterForNotifications",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationBotServer).UnregisterForNotifications(ctx, req.(*NotificationUnregisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationBot_RegisterForNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationBotServer).RegisterForNotifications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.NotificationBot/RegisterForNotifications",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationBotServer).RegisterForNotifications(ctx, req.(*NotificationRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationBot_ReceiveNotificationBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(messages.AuthenticatedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationBotServer).ReceiveNotificationBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.NotificationBot/ReceiveNotificationBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationBotServer).ReceiveNotificationBatch(ctx, req.(*messages.AuthenticatedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

// NotificationBot_ServiceDesc is the grpc.ServiceDesc for NotificationBot service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NotificationBot_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.NotificationBot",
	HandlerType: (*NotificationBotServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UnregisterForNotifications",
			Handler:    _NotificationBot_UnregisterForNotifications_Handler,
		},
		{
			MethodName: "RegisterForNotifications",
			Handler:    _NotificationBot_RegisterForNotifications_Handler,
		},
		{
			MethodName: "ReceiveNotificationBatch",
			Handler:    _NotificationBot_ReceiveNotificationBatch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}

// UDBClient is the client API for UDB service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UDBClient interface {
	// RegisterUser adds a new ID to the user discovery system
	RegisterUser(ctx context.Context, in *UDBUserRegistration, opts ...grpc.CallOption) (*messages.Ack, error)
	// RemoveUser deletes this user registration and blocks anyone from ever
	// registering under that username again.
	// The fact removal request must be for the username or it will not work.
	RemoveUser(ctx context.Context, in *FactRemovalRequest, opts ...grpc.CallOption) (*messages.Ack, error)
	// RegisterFact starts the association of a fact with an ID. This is
	// completed if it is a username and confirmations are required for verifiable
	// facts like e-mail address and phone numbers.
	RegisterFact(ctx context.Context, in *FactRegisterRequest, opts ...grpc.CallOption) (*FactRegisterResponse, error)
	// ConfirmFact completes the association of a fact with an ID
	ConfirmFact(ctx context.Context, in *FactConfirmRequest, opts ...grpc.CallOption) (*messages.Ack, error)
	// RemoveFact deletes a fact from its associated ID.
	// You cannot RemoveFact on a username. Callers must RemoveUser and reregsiter.
	RemoveFact(ctx context.Context, in *FactRemovalRequest, opts ...grpc.CallOption) (*messages.Ack, error)
}

type uDBClient struct {
	cc grpc.ClientConnInterface
}

func NewUDBClient(cc grpc.ClientConnInterface) UDBClient {
	return &uDBClient{cc}
}

func (c *uDBClient) RegisterUser(ctx context.Context, in *UDBUserRegistration, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.UDB/RegisterUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uDBClient) RemoveUser(ctx context.Context, in *FactRemovalRequest, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.UDB/RemoveUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uDBClient) RegisterFact(ctx context.Context, in *FactRegisterRequest, opts ...grpc.CallOption) (*FactRegisterResponse, error) {
	out := new(FactRegisterResponse)
	err := c.cc.Invoke(ctx, "/mixmessages.UDB/RegisterFact", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uDBClient) ConfirmFact(ctx context.Context, in *FactConfirmRequest, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.UDB/ConfirmFact", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uDBClient) RemoveFact(ctx context.Context, in *FactRemovalRequest, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.UDB/RemoveFact", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UDBServer is the server API for UDB service.
// All implementations must embed UnimplementedUDBServer
// for forward compatibility
type UDBServer interface {
	// RegisterUser adds a new ID to the user discovery system
	RegisterUser(context.Context, *UDBUserRegistration) (*messages.Ack, error)
	// RemoveUser deletes this user registration and blocks anyone from ever
	// registering under that username again.
	// The fact removal request must be for the username or it will not work.
	RemoveUser(context.Context, *FactRemovalRequest) (*messages.Ack, error)
	// RegisterFact starts the association of a fact with an ID. This is
	// completed if it is a username and confirmations are required for verifiable
	// facts like e-mail address and phone numbers.
	RegisterFact(context.Context, *FactRegisterRequest) (*FactRegisterResponse, error)
	// ConfirmFact completes the association of a fact with an ID
	ConfirmFact(context.Context, *FactConfirmRequest) (*messages.Ack, error)
	// RemoveFact deletes a fact from its associated ID.
	// You cannot RemoveFact on a username. Callers must RemoveUser and reregsiter.
	RemoveFact(context.Context, *FactRemovalRequest) (*messages.Ack, error)
	mustEmbedUnimplementedUDBServer()
}

// UnimplementedUDBServer must be embedded to have forward compatible implementations.
type UnimplementedUDBServer struct {
}

func (UnimplementedUDBServer) RegisterUser(context.Context, *UDBUserRegistration) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterUser not implemented")
}
func (UnimplementedUDBServer) RemoveUser(context.Context, *FactRemovalRequest) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUser not implemented")
}
func (UnimplementedUDBServer) RegisterFact(context.Context, *FactRegisterRequest) (*FactRegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterFact not implemented")
}
func (UnimplementedUDBServer) ConfirmFact(context.Context, *FactConfirmRequest) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmFact not implemented")
}
func (UnimplementedUDBServer) RemoveFact(context.Context, *FactRemovalRequest) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFact not implemented")
}
func (UnimplementedUDBServer) mustEmbedUnimplementedUDBServer() {}

// UnsafeUDBServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UDBServer will
// result in compilation errors.
type UnsafeUDBServer interface {
	mustEmbedUnimplementedUDBServer()
}

func RegisterUDBServer(s grpc.ServiceRegistrar, srv UDBServer) {
	s.RegisterService(&UDB_ServiceDesc, srv)
}

func _UDB_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UDBUserRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UDBServer).RegisterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.UDB/RegisterUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UDBServer).RegisterUser(ctx, req.(*UDBUserRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

func _UDB_RemoveUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FactRemovalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UDBServer).RemoveUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.UDB/RemoveUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UDBServer).RemoveUser(ctx, req.(*FactRemovalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UDB_RegisterFact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FactRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UDBServer).RegisterFact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.UDB/RegisterFact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UDBServer).RegisterFact(ctx, req.(*FactRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UDB_ConfirmFact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FactConfirmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UDBServer).ConfirmFact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.UDB/ConfirmFact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UDBServer).ConfirmFact(ctx, req.(*FactConfirmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UDB_RemoveFact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FactRemovalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UDBServer).RemoveFact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.UDB/RemoveFact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UDBServer).RemoveFact(ctx, req.(*FactRemovalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UDB_ServiceDesc is the grpc.ServiceDesc for UDB service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UDB_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.UDB",
	HandlerType: (*UDBServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterUser",
			Handler:    _UDB_RegisterUser_Handler,
		},
		{
			MethodName: "RemoveUser",
			Handler:    _UDB_RemoveUser_Handler,
		},
		{
			MethodName: "RegisterFact",
			Handler:    _UDB_RegisterFact_Handler,
		},
		{
			MethodName: "ConfirmFact",
			Handler:    _UDB_ConfirmFact_Handler,
		},
		{
			MethodName: "RemoveFact",
			Handler:    _UDB_RemoveFact_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}

// AuthorizerClient is the client API for Authorizer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthorizerClient interface {
	Authorize(ctx context.Context, in *AuthorizerAuth, opts ...grpc.CallOption) (*messages.Ack, error)
}

type authorizerClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthorizerClient(cc grpc.ClientConnInterface) AuthorizerClient {
	return &authorizerClient{cc}
}

func (c *authorizerClient) Authorize(ctx context.Context, in *AuthorizerAuth, opts ...grpc.CallOption) (*messages.Ack, error) {
	out := new(messages.Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Authorizer/Authorize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthorizerServer is the server API for Authorizer service.
// All implementations must embed UnimplementedAuthorizerServer
// for forward compatibility
type AuthorizerServer interface {
	Authorize(context.Context, *AuthorizerAuth) (*messages.Ack, error)
	mustEmbedUnimplementedAuthorizerServer()
}

// UnimplementedAuthorizerServer must be embedded to have forward compatible implementations.
type UnimplementedAuthorizerServer struct {
}

func (UnimplementedAuthorizerServer) Authorize(context.Context, *AuthorizerAuth) (*messages.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Authorize not implemented")
}
func (UnimplementedAuthorizerServer) mustEmbedUnimplementedAuthorizerServer() {}

// UnsafeAuthorizerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthorizerServer will
// result in compilation errors.
type UnsafeAuthorizerServer interface {
	mustEmbedUnimplementedAuthorizerServer()
}

func RegisterAuthorizerServer(s grpc.ServiceRegistrar, srv AuthorizerServer) {
	s.RegisterService(&Authorizer_ServiceDesc, srv)
}

func _Authorizer_Authorize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthorizerAuth)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorizerServer).Authorize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Authorizer/Authorize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorizerServer).Authorize(ctx, req.(*AuthorizerAuth))
	}
	return interceptor(ctx, in, info, handler)
}

// Authorizer_ServiceDesc is the grpc.ServiceDesc for Authorizer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Authorizer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.Authorizer",
	HandlerType: (*AuthorizerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Authorize",
			Handler:    _Authorizer_Authorize_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}
